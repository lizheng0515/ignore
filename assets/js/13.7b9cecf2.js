(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{311:function(t,v,a){t.exports=a.p+"assets/img/frame-1.cd25f48f.jpg"},312:function(t,v,a){t.exports=a.p+"assets/img/frame-2.a0322568.jpg"},313:function(t,v,a){t.exports=a.p+"assets/img/frame-3.b9f1dc4a.jpg"},420:function(t,v,a){"use strict";a.r(v);var _=a(2),e=Object(_.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"前端框架演变"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端框架演变"}},[t._v("#")]),t._v(" 前端框架演变")]),t._v(" "),_("h2",{attrs:{id:"web1-0时代"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#web1-0时代"}},[t._v("#")]),t._v(" web1.0时代")]),t._v(" "),_("p",[t._v("此时前端展示数据比较简单，通常是由后台使用模板引擎直接渲染的。在这个时期都还未产生“前端工程师”，更别谈前端的发展能有多快了。这个时代作者经历的并不多，比较也已经过去了很多年了，这里就不深究。")]),t._v(" "),_("h2",{attrs:{id:"web2-0时代"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#web2-0时代"}},[t._v("#")]),t._v(" web2.0时代")]),t._v(" "),_("blockquote",[_("p",[t._v("前端展示趋于复杂，所以逐渐就开始前后端分离式架构。此时有一个关键词ugc: user generate content 用户生成内容，也意味着交互越来越复杂，故而逐渐产生了“前端工程师”，专门来维护这些复杂的交互界面，后台也可以专注于本该属于他们自己的业务逻辑以及业务架构中。")])]),t._v(" "),_("h3",{attrs:{id:"第一个时期：div-css布局解放：面向-dom-编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第一个时期：div-css布局解放：面向-dom-编程"}},[t._v("#")]),t._v(" 第一个时期：DIV+CSS布局解放：面向 DOM 编程")]),t._v(" "),_("blockquote",[_("p",[t._v("在面向DOM编程过程非常直观并且易操作，有一个缺点就是大量的代码冗余，例如获取元素等，于是乎就诞生了伟大的jQuery库")])]),t._v(" "),_("p",[t._v("jquery优势：")]),t._v(" "),_("ol",[_("li",[t._v("轻量级(采用 UglifyJS 压缩后，大小保持在30kb左右)")]),t._v(" "),_("li",[t._v("强大的选择器")]),t._v(" "),_("li",[t._v("出色的DOM操作的封装")]),t._v(" "),_("li",[t._v("可靠的事件处理机制")]),t._v(" "),_("li",[t._v("对Ajax的封装完善")]),t._v(" "),_("li",[t._v("不污染顶级变量(jQuery只建立一个名为jQuery的对象)")]),t._v(" "),_("li",[t._v("出色的浏览器兼容性")]),t._v(" "),_("li",[t._v("链式操作方式")]),t._v(" "),_("li",[t._v("丰富的插件支持")])]),t._v(" "),_("h3",{attrs:{id:"第二个时期：ajax-动态网页：面向数据编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第二个时期：ajax-动态网页：面向数据编程"}},[t._v("#")]),t._v(" 第二个时期：Ajax 动态网页：面向数据编程")]),t._v(" "),_("blockquote",[_("p",[t._v("Ajax直接拯救了JavaScript这么语言。")])]),t._v(" "),_("p",[t._v("我们终于可以再提交一个表单的时候，不需要再刷新界面了。给了用户一个非常好的用户体验，最初在google的GMAIL中取得巨大的成功。逐渐全世界风靡。彼时的程序员的一个重要考核标准就是能不能熟练掌握"),_("code",[t._v("Ajax")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"第三个时期：浏览器兼容：面向浏览器编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第三个时期：浏览器兼容：面向浏览器编程"}},[t._v("#")]),t._v(" 第三个时期：浏览器兼容：面向浏览器编程")]),t._v(" "),_("blockquote",[_("p",[t._v("随着浏览器的种类繁多，以及它们都有自己的一套标准，使得研发人员在编写代码的时候要兼容多浏览器，于是乎就产生了两种编程思想")])]),t._v(" "),_("ul",[_("li",[t._v("向下兼容思想(做设计时要考虑到兼容到低版本浏览器)")]),t._v(" "),_("li",[t._v("渐进增强思想(高版本的浏览器使用最新的技术，低版本浏览器使用老旧点的技术)")])]),t._v(" "),_("p",[t._v("就譬如"),_("code",[t._v("reset.css")]),t._v("就是为了统一浏览器展示而存在的。")]),t._v(" "),_("h3",{attrs:{id:"第四个时期：spa-大型前端：面向模块编程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第四个时期：spa-大型前端：面向模块编程"}},[t._v("#")]),t._v(" 第四个时期：SPA 大型前端：面向模块编程")]),t._v(" "),_("blockquote",[_("p",[t._v("随着项目的复杂度越高，前端也开始仿制后端进行模块化编程，例如现在流行的前端三大框架Angular、React、Vue，都是MV*架构模式")])]),t._v(" "),_("p",[t._v("逐渐的我们可以开发中用户体验更佳的web应用了，用户调整一个路由再也不需要等待后台的界面返回了，用户可以快速的切换各个界面间，而只需要付出极小的“带宽”")]),t._v(" "),_("p",[t._v("至于未来的前端技术还会如何发展，我们也需要尽更时代的发展了。")]),t._v(" "),_("h2",{attrs:{id:"通过技术层面来看看变换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通过技术层面来看看变换"}},[t._v("#")]),t._v(" 通过技术层面来看看变换")]),t._v(" "),_("h3",{attrs:{id:"从jquery操作dom-到-框架的演变"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#从jquery操作dom-到-框架的演变"}},[t._v("#")]),t._v(" 从"),_("code",[t._v("jquery")]),t._v("操作"),_("code",[t._v("DOM")]),t._v(" 到 框架的演变")]),t._v(" "),_("p",[t._v("【操作DOM】\n普通代码编写时，jquery直接操作DOM去做一些增删改查的工作，当项目的增大，代码也是越来越复杂，非常不好管理。于是这个时候就开始借鉴后端的模板引擎的思想，为什么要一直操作DOM去增删改查，这样显得太麻烦了，为什么不先定义好数据模型，不论什么操作，我们先更改模型里面的数据，然后在通过模板一次性去render到界面上去，这样就类似react这些框架只操作数据去改变界面了。使得代码可管理型增强了好多。")]),t._v(" "),_("p",[_("img",{attrs:{src:a(311),alt:"img"}})]),t._v(" "),_("p",[t._v("【mvc】")]),t._v(" "),_("p",[t._v("基于上图，于是乎就出现了一个非常知名的前端MVC分层管理框架"),_("code",[t._v("backbone")])]),t._v(" "),_("p",[_("img",{attrs:{src:a(312),alt:"img"}})]),t._v(" "),_("p",[t._v("M(Model)：数据模型层\nV(View)：视图层，负责展示界面的层\nC(Controller)：控制层，主要就是操作数据来渲染视图的层")]),t._v(" "),_("p",[t._v("【现代框架】")]),t._v(" "),_("blockquote",[_("p",[t._v("框架是对一个完整代码组织方法的描述")])]),t._v(" "),_("p",[t._v("当大家意识到，每次请求一个页面都要向后台去发送一个请求，有时候似乎是比较浪费资源的，并且一些重复的已经看过的界面任然要去向后台请求，大家开始思考组件化加上前端自定义路由的重要性，这样只需要加载一次代码，通过前端自定义路由实现界面之间的跳转，不用再向后台请求界面了，速度和体验一下子增加了不少。")]),t._v(" "),_("p",[t._v("正因为这些问题于是乎就诞生了现代框架：Angular Vue React")]),t._v(" "),_("p",[t._v("【优势劣势】")]),t._v(" "),_("p",[_("img",{attrs:{src:a(313),alt:"img"}})])])}),[],!1,null,null,null);v.default=e.exports}}]);