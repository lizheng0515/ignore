(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{399:function(e,v,_){"use strict";_.r(v);var t=_(2),r=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"你应该要知道的vue-js"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#你应该要知道的vue-js"}},[e._v("#")]),e._v(" 你应该要知道的Vue.js")]),e._v(" "),_("blockquote",[_("p",[e._v("该篇文章主要对Vue中应该要掌握的知识点的一些整理。只是一个引子，并没有过多的深入，但是希望能根据这篇文章从各个点对Vue有一个更好的了解，对自己有一个更好的定位。只会用API的前端不是好的程序员。")])]),e._v(" "),_("h3",{attrs:{id:"组件data为什么必须是函数？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#组件data为什么必须是函数？"}},[e._v("#")]),e._v(" 组件data为什么必须是函数？")]),e._v(" "),_("p",[e._v("因为组件可能被多处使用，但它们的data是私有的，所以每个组件都要return一个新的data对象，如果共享data，修改其中一个会影响其他组件")]),e._v(" "),_("h3",{attrs:{id:"组件通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#组件通信"}},[e._v("#")]),e._v(" 组件通信")]),e._v(" "),_("ul",[_("li",[e._v("父子组件通信："),_("code",[e._v("$on")]),e._v("、"),_("code",[e._v("$emit")])]),e._v(" "),_("li",[e._v("非父子组件的通信: event bus")]),e._v(" "),_("li",[e._v("复杂情况： vuex")])]),e._v(" "),_("h3",{attrs:{id:"怎么动态添加组件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#怎么动态添加组件"}},[e._v("#")]),e._v(" 怎么动态添加组件")]),e._v(" "),_("p",[e._v("场景：在vue中，点击button，随机生成a、b、c组件中的一个")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("is")])]),e._v(" "),_("li",[_("code",[e._v("render")])])]),e._v(" "),_("p",[e._v("思路：设定一个components数组，button点击一次，push一个组件名，"),_("code",[e._v("v-for")]),e._v("遍历components，并用"),_("code",[e._v("is")]),e._v("或"),_("code",[e._v("render")]),e._v("动态生成")]),e._v(" "),_("h3",{attrs:{id:"vue-loader是什么？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue-loader是什么？"}},[e._v("#")]),e._v(" vue-loader是什么？")]),e._v(" "),_("p",[e._v("vue-loader 是一个 webpack 的 loader，可以将单文件组件转换为 JavaScript 模块")]),e._v(" "),_("p",[e._v("引用文档的说法：")]),e._v(" "),_("ul",[_("li",[e._v("默认支持 "),_("code",[e._v("ES2015")]),e._v("；")]),e._v(" "),_("li",[e._v("允许对 Vue 组件的组成部分使用其它 "),_("code",[e._v("webpack loader")]),e._v("，比如对 "),_("code",[e._v("<style>")]),e._v(" 使用 "),_("code",[e._v("Sass")]),e._v(" 和对 "),_("code",[e._v("<template>")]),e._v(" 使用 "),_("code",[e._v("Jade")]),e._v("；")]),e._v(" "),_("li",[_("code",[e._v(".vue")]),e._v(" 文件中允许自定义节点，然后使用自定义的 loader 进行处理；")]),e._v(" "),_("li",[e._v("把 "),_("code",[e._v("<style>")]),e._v(" 和 "),_("code",[e._v("<template>")]),e._v(" 中的静态资源当作模块来对待，并使用 "),_("code",[e._v("webpack loader")]),e._v(" 进行处理；")]),e._v(" "),_("li",[e._v("对每个组件模拟出 CSS 作用域；")]),e._v(" "),_("li",[e._v("支持开发期组件的热重载。")])]),e._v(" "),_("h3",{attrs:{id:"实现-vue-ssr基本原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现-vue-ssr基本原理"}},[e._v("#")]),e._v(" 实现 Vue SSR基本原理")]),e._v(" "),_("p",[e._v("主要通过"),_("code",[e._v("vue-server-renderer")]),e._v("将Vue组件输出成HTML，过程：")]),e._v(" "),_("ol",[_("li",[e._v("客户端 entry-client 主要作用挂载到 DOM 上，服务端 entry-server 除了创建和返回实例，还进行路由匹配与数据预获取")]),e._v(" "),_("li",[e._v("webpack打包客户端为client-bundle，打包服务端为server-bundle")]),e._v(" "),_("li",[e._v("服务器接收请求，根据 url 来加载相应组件，然后生成 html 发送给客户端")]),e._v(" "),_("li",[e._v("客户端激活， Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM，为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window."),_("strong",[e._v("INITIAL_STATE")]),e._v(" 发送到客户端")])]),e._v(" "),_("h3",{attrs:{id:"数据双向绑定原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据双向绑定原理"}},[e._v("#")]),e._v(" 数据双向绑定原理")]),e._v(" "),_("p",[e._v("实现数据绑定的常见做法：")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("Object.defineProperty")]),e._v("：劫持各个属性的"),_("code",[e._v("setter")]),e._v("，"),_("code",[e._v("getter")])]),e._v(" "),_("li",[e._v("脏值检测：通过特定事件进行轮循")]),e._v(" "),_("li",[e._v("发布/订阅模式：通过消息发布并将消息进行订阅")])]),e._v(" "),_("p",[e._v("vue采用的是数据劫持结合发布者-订阅者模式的方式，通过"),_("code",[e._v("Object.defineProperty()")]),e._v("来实现对属性的劫持，并在数据变动时发布消息给订阅者，使其触发相应的监听回调。")]),e._v(" "),_("p",[e._v("具体步骤：")]),e._v(" "),_("p",[e._v("1、 实现Observer")]),e._v(" "),_("p",[e._v("将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上"),_("code",[e._v("setter")]),e._v("和"),_("code",[e._v("getter")]),e._v("。实现一个消息订阅器，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法")]),e._v(" "),_("p",[e._v("2、 实现Compile")]),e._v(" "),_("p",[e._v("compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")]),e._v(" "),_("p",[e._v("3、 实现Watcher")]),e._v(" "),_("p",[e._v("Watcher订阅者是Observer和Compile之间通信的桥梁")]),e._v(" "),_("p",[e._v("主要做的事情是:")]),e._v(" "),_("ul",[_("li",[e._v("在自身实例化时往属性订阅器(dep)里面添加自己")]),e._v(" "),_("li",[e._v("自身必须有一个update()方法")]),e._v(" "),_("li",[e._v("待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。")])]),e._v(" "),_("p",[e._v("4、 实现MVVM")]),e._v(" "),_("p",[e._v("MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果")]),e._v(" "),_("p",[e._v("参考："),_("a",{attrs:{href:"https://segmentfault.com/a/1190000006599500#articleHeader4",target:"_blank",rel:"noopener noreferrer"}},[e._v("剖析Vue原理&实现双向绑定MVVM"),_("OutboundLink")],1)]),e._v(" "),_("h3",{attrs:{id:"对vue-js的template编译的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对vue-js的template编译的理解"}},[e._v("#")]),e._v(" 对Vue.js的template编译的理解")]),e._v(" "),_("p",[e._v("template会被编译成AST语法树，AST会经过generate得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点")]),e._v(" "),_("ul",[_("li",[e._v("parse 过程，将 template 利用正则转化成 AST 抽象语法树。")]),e._v(" "),_("li",[e._v("optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。")]),e._v(" "),_("li",[e._v("generate 过程，生成 render 字符串")])]),e._v(" "),_("p",[e._v("司徒大佬有一篇很好的文章："),_("a",{attrs:{href:"https://segmentfault.com/a/1190000006990480",target:"_blank",rel:"noopener noreferrer"}},[e._v("前端模板的原理与实现"),_("OutboundLink")],1)]),e._v(" "),_("h3",{attrs:{id:"vue-为什么采用virtual-dom？"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue-为什么采用virtual-dom？"}},[e._v("#")]),e._v(" vue 为什么采用"),_("code",[e._v("Virtual DOM")]),e._v("？")]),e._v(" "),_("p",[e._v("一方面是出于性能方面的考量：")]),e._v(" "),_("ul",[_("li",[e._v("创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。")]),e._v(" "),_("li",[e._v("触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流")])]),e._v(" "),_("p",[e._v("但是性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 "),_("code",[e._v("Virtual DOM")]),e._v("哪个的性能更好不是一个容易下定论的问题。更重要的原因是为了解耦"),_("code",[e._v("HTML")]),e._v("依赖，这带来两个非常重要的好处是：")]),e._v(" "),_("ul",[_("li",[e._v("不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升；")]),e._v(" "),_("li",[e._v("可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，Weex 等框架应用的就是这一特性。")])]),e._v(" "),_("p",[e._v("综上，"),_("code",[e._v("Virtual DOM")]),e._v(" 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。")]),e._v(" "),_("h3",{attrs:{id:"diff算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#diff算法"}},[e._v("#")]),e._v(" diff算法")]),e._v(" "),_("p",[e._v("这部分比较复杂，不好懂，推荐一篇不错的文章： "),_("a",{attrs:{href:"https://github.com/aooy/blog/issues/2",target:"_blank",rel:"noopener noreferrer"}},[e._v("解析vue2.0的diff算法"),_("OutboundLink")],1)]),e._v(" "),_("h3",{attrs:{id:"vue-和-react-区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-react-区别"}},[e._v("#")]),e._v(" vue 和 react 区别")]),e._v(" "),_("p",[e._v("相同点:")]),e._v(" "),_("ul",[_("li",[e._v("都支持"),_("code",[e._v("SSR")])]),e._v(" "),_("li",[e._v("都有"),_("code",[e._v("Virtual DOM")])]),e._v(" "),_("li",[e._v("组件化开发")]),e._v(" "),_("li",[e._v("数据驱动")]),e._v(" "),_("li",[e._v("...")])]),e._v(" "),_("p",[e._v("不同点:")]),e._v(" "),_("ul",[_("li",[e._v("vue推荐的是使用 webpack + vue-loader 的单文件组件格式，React 推荐的做法是 JSX + inline style")]),e._v(" "),_("li",[e._v("vue 的"),_("code",[e._v("Virtual DOM")]),e._v("是追踪每个组件的依赖关系，不会渲染整个组件树，react 每当应该状态被改变时，全部子组件都会 re-render")]),e._v(" "),_("li",[e._v("...")])])])}),[],!1,null,null,null);v.default=r.exports}}]);